/* Concurrent fine grained list using a lock per node
 * Wenhao Wu, Eric Kurtz, and Josh Davis
 * May-1-2018
 * VIP-HPC University of Delaware
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <limits.h>
#include "../include/list.cvh"

struct _lock
{
  $proc owner;
  int count;
};

typedef struct _lock Lock;

typedef struct _node Node;

struct _node
{
  int item;
  int key;
  Node* next;
  Lock* lock;
};

struct _list
{
  int size;
  Node* head;
};

typedef struct _list List;

List* list_create() {
  List* result = (List*) malloc(sizeof(List));
  result->size = 0;
  result->head = (Node*) malloc(sizeof(Node));
  result->head->lock = (Lock*) malloc(sizeof(Lock));
  result->head->lock->owner = $proc_null;
  result->head->lock->count = 0;
  result->head->next = (Node*) malloc(sizeof(Node));
  result->head->item = -1;
  result->head->next->item = -1;
  result->head->key = INT_MIN;
  result->head->next->key = INT_MAX;
  result->head->next->next = NULL;
  result->head->next->lock = (Lock*) malloc(sizeof(Lock));
  result->head->next->lock->owner = $proc_null;
  result->head->next->lock->count = 0;
  return result;
}

void lock_acquire(Lock* l) {
  $atomic {
    if ($self != l->owner) {
      $when(l->owner == $proc_null) l->owner = $self;
    }
    l->count++;
  }
}

void lock_release(Lock * l) {
  $atomic {
    $assert($self == l->owner);
    l->count--;
    if (l->count == 0) l->owner = $proc_null;
  }
}

int hash(int i) {
  return i;
}

void node_destroy(Node* head) {
  Node* current_node = head;
  if (current_node->next != NULL) {
    node_destroy(current_node->next);
  }
  free(current_node->lock);
  free(current_node);
}

_Bool list_destroy(List* list) {
  node_destroy(list->head);
  free(list);
  return true;
}

void list_print(List* list) {
  Node* curr = list->head;
  while (curr != NULL) {
    printf("(%d,%d) ", curr->key, curr->item);
    curr = curr->next;
  }
  printf("\n");
}

_Bool validate(List* list, Node* pred, Node* curr) {
  Node* entry = list->head;
  while (entry->key <= pred->key) {
    if (entry == pred) {
      return (pred->next == curr);
    }
    entry = entry->next;
  }
  return false;
}

_Bool list_contains(List* list, int item) {
  int key = hash(item);
  while (true) {
    Node* pred = list->head;
    Node* curr = pred->next;
    while (curr->key < key) {
      pred = curr;
      curr = curr->next;
    }
    lock_acquire(pred->lock);
    lock_acquire(curr->lock);
    if (validate(list, pred, curr)) {
      _Bool result = (curr->key == key);
      lock_release(pred->lock);
      lock_release(curr->lock);
      return result;
    }
    lock_release(pred->lock);
    lock_release(curr->lock);
  }
}

_Bool list_add(List* list, int item) {
  int key = hash(item);
  while (true) {
    Node* pred = list->head;
    Node* curr = pred->next;
    while (curr->key < key) {
      pred = curr;
      curr = curr->next;
    }
    lock_acquire(pred->lock);
    lock_acquire(curr->lock);
    if (validate(list, pred, curr)) {
      if (curr->key == key) {
	lock_release(pred->lock);
	lock_release(curr->lock);
	return false;
      } else {
	printf("List state before adding:\n");
	list_print(list);
	Node* new_node = (Node*) malloc(sizeof(Node));
	new_node->next = curr;
	new_node->lock = (Lock*) malloc(sizeof(Lock));
	new_node->lock->count = 0;
	new_node->lock->owner = $proc_null;
	pred->next = new_node;
	list->size++;
	new_node->key = key;
	new_node->item = item;
	printf("List state after adding:\n");
	list_print(list);
	lock_release(pred->lock);
	lock_release(curr->lock);
	return true;
      }
    }
    lock_release(pred->lock);
    lock_release(curr->lock);
  }
}

_Bool list_remove(List* list, int item) {
  int key = hash(item);
  while (true) {
    Node* pred = list->head;
    Node* curr = pred->next;
    while (curr->key < key) {
      pred = curr;
      curr = curr->next;
    }
    lock_acquire(pred->lock);
    lock_acquire(curr->lock);
    if (validate(list, pred, curr)) {
      if (curr->key == key) {
	pred->next = curr->next;
	curr->next = NULL;
	curr->key = -1;
	curr->item = -1;
	free(curr->lock);
	free(curr);
	lock_release(pred->lock);
	return true;
      } else {
	lock_release(pred->lock);
	lock_release(curr->lock);
	return false;
      }
    }
    lock_release(pred->lock);
    lock_release(curr->lock);
  }
}


void main() {
  List* list = list_create();
  
  $parfor(int i : 0 .. 1) {
    list_add(list, i);
  }
  $for(int j : 0 .. 1) {
    $assert(list_contains(list, j));
  }
  /*
  $parfor(int i : 0 .. 2) {
    list_remove(list, i);
  }
  $for(int j : 0 .. 2) {
    $assert(!list_contains(list, j));
  }
  */
  //list_print(list);
  list_destroy(list);
}
