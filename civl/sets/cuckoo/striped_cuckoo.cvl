/* Concurrent cuckoo hashset using lock striping and phasing
 * Wenhao Wu, Eric Kurtz, and Josh Davis
 * April-26-2018
 * VIP-HPC University of Delaware
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include "../include/set.cvh"

int INITIAL_STAGE = 0;
int INITIAL_SIZE = 1;
int PROBE_SIZE = 2;
int THRESHOLD = PROBE_SIZE / 2;
int LIMIT = 1;

int STAGE_BOUND = 1;
int VALUE_BOUND = 4;

int hash_vals[2][VALUE_BOUND]; 

typedef struct _node Node;

struct _node
{
  int data;
  Node* next;
};

struct _lock
{
  $proc owner;
  int count;
};

typedef struct _lock Lock;

struct _set
{
  int size;
  int stage;
  Node** table[2];
  Lock *locks[2];
};

typedef struct _set Set;

void init_hash_functions() {
  for (int t = 0; t < 2; t++){ 
    for (int i = 0; i < VALUE_BOUND; i++){
      hash_vals[t][i] = -1;
    }
  }
}

void print_hashes() {
  for (int t = 0; t < 2; t++){ 
    printf("hashes %d\n", t);
    for (int i = 0; i < VALUE_BOUND; i++){
      printf("%s ", hash_vals[t][i]);
    }
    printf("\n");
  }
}



Node* node_add(Node* head, int data) {
  Node* new_node = (Node*) malloc(sizeof(Node));
  new_node->data = data;
  new_node->next = NULL;
  head->next = new_node;
  return new_node;
}

Node* probe_write(Node* head, int data) {
  Node* current_node = head;
  //printf("Current_node = %s\n", current_node);
  //printf("Current_node->data = %s\n", current_node->data);
  while (current_node != NULL && current_node->data != -1) {
    //printf("Incrementing current_node!\n");
    current_node = current_node->next;
    //printf("Current_node = %s\n", current_node);
    //printf("Current_node->data = %s\n", current_node->data);
  }
  if (current_node->data == -1) {
    current_node->data = data; //?
    printf("Wrote current_node->data as %s\n", current_node->data);
  }
  else printf("PROBE WRITE FAILED: No empty node found\n");
}

int probe_length(Node* head) {
  int result = 0;
  Node* current_node = head;
  while (current_node != NULL && current_node->data != -1) {
    result++;
    current_node = current_node->next;
  }
  return result;
}

void probe_destroy(Node* head) {
  Node* current_node = head;
  if (current_node->next != NULL) {
    probe_destroy(current_node->next);
  }
  free(current_node);
}

int probe_get(Node* head, int index) {
  int i = 0;
  Node* current_node = head;
  while (current_node != NULL && current_node->data != -1) {
    if (i == index) {
      return current_node->data;
    }
    i++;
    current_node = current_node->next;
  }
  printf("PROBE GET FAILED: Bad index or no data in probe\n");
  return -1;
}

_Bool probe_remove(Node* head, int data, int i, int hi, Set* set) {
  Node* current_node = set->table[i][hi];
  Node* prev_node = NULL;
  _Bool found = false;
  while (current_node != NULL && current_node->data != -1) {
    if (current_node->data == data) {
      Node* tmp = current_node;
      if (prev_node == NULL) set->table[i][hi] = tmp->next;
      else prev_node->next = tmp->next;
      tmp->next = NULL;
      free(tmp);
      found = true;
      break;
    }
    else {
      prev_node = current_node;
      current_node = current_node->next;
    }
  }
  if (!found) return false;
  current_node = set->table[i][hi];
  while (current_node->next != NULL) {
    current_node = current_node->next;
  }
  node_add(current_node, -1);
  //printf("probe_remove complete\n");
  return true;
}

void print_nodes(Node* head) {
  Node* current_node = head;
  while (current_node != NULL/* && current_node->data != -1*/) {
    printf("%d ", current_node->data);
    if (current_node->next != NULL) current_node = current_node->next;
    else current_node = NULL;
  }
  printf("\n");
}

Set* set_create() {
  Set* result = (Set*) malloc(sizeof(Set));
  result->size = INITIAL_SIZE;
  result->stage = INITIAL_STAGE;
  for (int i=0; i<2; i++) {
    result->locks[i] = malloc(result->size*sizeof(Lock));
    result->table[i] = malloc(result->size*sizeof(Node*));
    for (int j=0; j<result->size; j++) {
      result->locks[i][j].owner = $proc_null;
      result->locks[i][j].count = 0;
      result->table[i][j] = (Node*) malloc(sizeof(Node));
      result->table[i][j]->data = -1;
      Node* current_head = result->table[i][j];
      for (int k=0; k<PROBE_SIZE-1; k++) {
        current_head = node_add(current_head, -1);
      }
      current_head->next = NULL;
    }
  }
  return result;
}

/*
Node* list_build(int size) {
  Node* head = ;
  for (int i = 0; i < size-1; i++) {}
}
*/

int exp_two(int p) {
  int r = 1;
  for (int i = 0; i < p; i++) r = r * 2;
  return r;
}
//Change this to defined hash function to concrete value
/* 
$abstract int h0(int s, int x);
int hash0(Set* set, int x) {
  int r = h0(set->stage, x);
  $assume(0 <= r && r < $pow(2, set->stage));
  return r;
} 

$abstract int h1(int s, int x);
int hash1(Set* set, int x) {
  int r = h1(set->stage, x);
  $assume(0 <= r && r < $pow(2, set->stage));
  return r;
}
*/

int hash0(Set* set, int x) {
  if (hash_vals[0][x] == -1) {
    int s = exp_two(set->stage);
    int choice = $choose_int(s);
    hash_vals[0][x] = choice;
    return hash_vals[0][x];
  }
  else return hash_vals[0][x];
}

int hash1(Set* set, int x) {
  if (hash_vals[1][x] == -1) {
    int s = exp_two(set->stage);
    int choice = $choose_int(s);
    hash_vals[1][x] = choice;
    return hash_vals[1][x];
  }
  else return hash_vals[1][x]; 
}


_Bool set_destroy(Set* set) {
  for (int i=0; i<2; i++) {
    for (int j=0; j<set->size; j++) {
      probe_destroy(set->table[i][j]);
    }
    free(set->table[i]);
    free(set->locks[i]);
  }
  set->size = -1;
  free(set);
  return true;
}


void lock_acquire(Lock * l) {
  $atomic {
    if ($self != l->owner) {
      $when(l->owner == $proc_null) l->owner = $self;
    }
    l->count++;
  }
}

void lock_release(Lock * l) {
  $atomic {
    $assert($self == l->owner);
    l->count--;
    if (l->count == 0) l->owner = $proc_null;
  }
}

void acquire(Set* set, int x) {
  int h0 = hash0(set, x) % INITIAL_SIZE;
  int h1 = hash1(set, x) % INITIAL_SIZE;
  printf("Acquiring locks for x = %s...\n", x);
  lock_acquire(&(set->locks[0][h0]));
  lock_acquire(&(set->locks[1][h1]));
  printf("Acquired locks for x = %s!\n", x);
}

void release(Set* set, int x) {
  int h0 = hash0(set, x) % INITIAL_SIZE;
  int h1 = hash1(set, x) % INITIAL_SIZE;
  lock_release(&(set->locks[0][h0]));
  lock_release(&(set->locks[1][h1]));
  printf("Released locks for x = %s!\n", x);
}

void set_print(Set* set) {
  for (int i=0; i<2; i++) {
    printf("Table %d:\n", i);
    for (int j=0; j<set->size; j++) {
        printf("%d: ", j);
        print_nodes(set->table[i][j]);
    }
  }
}

_Bool set_contains(Set* set, int x) {
  printf("Entering set_contains function...\n");
  acquire(set, x);
  Node* current_node = set->table[0][hash0(set, x)];
  //printf("Current_node = %s\n", current_node);
  //printf("Current_node->data = %s\n", current_node->data);
  while (current_node != NULL && current_node->data != -1) {
    if (current_node->data == x)
    {
      release(set, x);
      return true;
    }
    current_node = current_node->next;
  }
  current_node = set->table[1][hash1(set, x)];
  while (current_node != NULL && current_node->data != -1) {
    if (current_node->data == x)
    {
      release(set, x);
      return true;
    }
    current_node = current_node->next;
  }
  release(set, x);
  return false;
}

// unsynchronized version of contains, call only from synchronized methods
_Bool present(Set* set, int x) {
  //printf("Entering present function...\n");
  Node* current_node = set->table[0][hash0(set, x)];
  $assert(current_node != NULL);
  while (current_node != NULL && current_node->data != -1) {
    if (current_node->data == x) return true;
    current_node = current_node->next;
  }
  current_node = set->table[1][hash1(set, x)];
  $assert(current_node != NULL);
  while (current_node != NULL && current_node->data != -1) {
    if (current_node->data == x) return true;
    current_node = current_node->next;
  }
  return false;
}

_Bool relocate(Set* set, int i, int hi) {
  printf("Entering relocate function...\n");
  int hj = 0;
  int j = 1 - i;
  for (int round = 0; round < LIMIT; round++) {
    Node* i_probe = set->table[i][hi];
    int y = probe_get(i_probe, 0);
    switch (i) {
      case 0: hj = hash1(set, y); break;
      case 1: hj = hash0(set, y); break;
    }
    acquire(set, y);
    Node* j_probe = set->table[j][hj];
    if (probe_remove(i_probe, y, i, hi, set)) {
      if (probe_length(j_probe) < THRESHOLD) {
        probe_write(j_probe, y);
	release(set, y);
	return true;
      }
      else if (probe_length(j_probe) < PROBE_SIZE) {
	//printf("Inserting above Threshold in table %d...\n", i);
	probe_write(j_probe, y);
        i = 1 - i;
        hi = hj;
        j = 1 - j;
	release(set, y);
      }
      else {
        probe_write(i_probe, y);
	release(set, y);
        return false;
      }
    }
    else if (probe_length(i_probe) >= THRESHOLD) {
      release(set, y);
      continue;
    }
    else {
      release(set, y);
      return true;
    }
  }
  printf("Limit exceeded!\n");
  set_print(set);
  return false;
}

_Bool set_add(Set* set, int x);

void resize(Set* set) {
  printf("RESIZING!!\n");
  set_print(set);
  int old_size = set->size;
  if (set->stage == STAGE_BOUND) return;
  printf("Acquiring all locks...\n");
  for (int i = 0; i < INITIAL_SIZE; i++) {
    lock_acquire(&(set->locks[0][i]));
    lock_acquire(&(set->locks[1][i]));
  }
  printf("Acquired all locks!\n");
  if (set->size != old_size) {
    for (int i = 0; i < INITIAL_SIZE; i++) {
      lock_release(&(set->locks[0][i]));
      lock_release(&(set->locks[1][i]));
    }
    printf("Released all locks!\n");
    return;
  }
  Node** old_table[2];
  for (int l = 0; l < 2; l++) {
    old_table[l] = set->table[l];
  }
  set->size = set->size * 2;
  set->stage++;
  init_hash_functions();
  for (int i=0; i<2; i++) {
    set->table[i] = NULL;
    set->table[i] = malloc(set->size*sizeof(Node*));
    for (int j=0; j<set->size; j++) {
      set->table[i][j] = (Node*) malloc(sizeof(Node));
      set->table[i][j]->data = -1;
      set->table[i][j]->next = NULL;
      Node* current_head = set->table[i][j];
      for (int k=0; k<PROBE_SIZE-1; k++) {
        current_head = node_add(current_head, -1);
      }
      current_head->next = NULL;
    }
  }
  Node* current_node = NULL;
  for (int j = 0; j < old_size; j++) {
    current_node = old_table[0][j];
    while (current_node != NULL && current_node->data != -1) {
      set_add(set, current_node->data);
      current_node = current_node->next;
    }
    current_node = old_table[1][j];
    while (current_node != NULL && current_node->data != -1) {
      set_add(set, current_node->data);
      current_node = current_node->next;
    }
  }
  for (int i=0; i < 2; i++) {
    for (int j=0; j < old_size; j++) {
      probe_destroy(old_table[i][j]);
    }
    free(old_table[i]);
  }
  for (int i = 0; i < INITIAL_SIZE; i++) {
    lock_release(&(set->locks[0][i]));
    lock_release(&(set->locks[1][i]));
  }
  printf("Released all locks!\n");
}

_Bool set_add(Set* set, int x) {
  acquire(set, x);
  int h0 = hash0(set, x);
  int h1 = hash1(set, x);
  int i = -1; //outer index of item to add
  int h = -1; //inner index of item to add
  _Bool must_resize = false;
  if (x<0 || present(set, x)) {
    release(set, x);
    return false;
  }
  //printf("Getting probe pointers...\n");
  Node* probe_0 = set->table[0][h0];
  Node* probe_1 = set->table[1][h1];
  if (probe_length(probe_0) < THRESHOLD) {
    //printf("Writing to probe 0 under threshold\n");
    probe_write(probe_0, x);
    release(set, x);
    return true;
  }
  else if (probe_length(probe_1) < THRESHOLD) {
    //printf("Writing to probe 1 under threshold\n");
    probe_write(probe_1, x);
    release(set, x);
    return true;
  }
  else if (probe_length(probe_0) < PROBE_SIZE) {
    //printf("Writing to probe 0 over threshold\n");
    probe_write(probe_0, x);
    i = 0;
    h = h0;
  }
  else if (probe_length(probe_1) < PROBE_SIZE) {
    // printf("Writing to probe 1 over threshold\n");
    probe_write(probe_1, x);
    i = 1;
    h = h1;
  }
  else must_resize = true;
  release(set, x);
  if (must_resize) {
    resize(set);
    set_add(set, x);
  }
  else if (!relocate(set, i, h)) {
    resize(set);
  }
  return true;
}

_Bool set_remove(Set* set, int x) {
  acquire(set, x);
  int h0 = hash0(set, x) % set->size;
  Node* table0 = set->table[0][h0];
  int h1 = hash1(set, x) % set->size;
  Node* table1 = set->table[1][h1];
  if (!probe_remove(table0, x, 0, h0, set)) {
    if (!probe_remove(table1, x, 1, h1, set)) {
      printf("ERROR: Given x not in set!\n");
      release(set, x);
      return false;
    }
  }
  release(set, x);
  return true;
}

int test1() {
  Set* s = set_create();

  set_add(s, 0);
  $assert(set_contains(s, 0));
  set_add(s, 1);
  $assert(set_contains(s, 1));
  set_add(s, 2);
  $assert(set_contains(s, 2));
  set_print(s);
  set_destroy(s);
}

int test_par() {
  Set* s = set_create();

  $parfor (int val : 0 .. VALUE_BOUND-1)
    set_add(s, val);

  set_print(s);

  $assert(set_contains(s, 0));
  $assert(set_contains(s, 1));
  $assert(set_contains(s, 2));

  $parfor (int val : 0 .. VALUE_BOUND-1)
    set_remove(s, val);

  set_print(s);

  $assert(!set_contains(s, 0));
  $assert(!set_contains(s, 1));
  $assert(!set_contains(s, 2));

  set_destroy(s);
}
/*
int main() {
  test_par();
}
*/
