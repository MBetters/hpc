#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include "../include/set.cvh"

int INITIAL_STAGE = 1;
int INITIAL_SIZE = 2;
int PROBE_SIZE = 4;
int THRESHOLD = PROBE_SIZE / 2;
int LIMIT = 8;

int STATE_BOUND = 2;
int VALUE_BOUND = 6;

int hash_vals[2][VALUE_BOUND]; 

typedef struct _node Node;

struct _node
{
  int data;
  Node* next;
};

struct _set
{
  int size;
  int stage;
  Node** table[2];
  _Bool *locks[2];
};

typedef struct _set Set;

void init_hash_functions() {
  for (int t = 0; t < 2; t++){ 
    for (int i = 0; i < VALUE_BOUND; i++){
      hash_vals[t][i] = -1;
    }
  }
}


void print_hashes() {
  for (int t = 0; t < 2; t++){ 
    printf("hashes %d\n", t);
    for (int i = 0; i < VALUE_BOUND; i++){
      printf("%s ", hash_vals[t][i]);
    }
    printf("\n");
  }
}



Node* node_add(Node* head, int data) {
  Node* new_node = (Node*) malloc(sizeof(Node));
  new_node->data = data;
  head->next = new_node;
  return new_node;
}

Node* probe_write(Node* head, int data) {
  Node* current_node = head;
  while (current_node != NULL && current_node->data != -1) {
    current_node = current_node->next;
  }
  if (current_node->data == -1) current_node->data = data; //This is broken
  else printf("PROBE WRITE FAILED: No empty node found\n");
}

int probe_length(Node* head) {
  int result = 0;
  Node* current_node = head;
  while (current_node != NULL && current_node->data != -1) {
    result++;
    current_node = current_node->next;
  }
  return result;
}

void probe_destroy(Node* head) {
  Node* current_node = head;
  if (current_node->next != NULL) {
    probe_destroy(current_node->next);
  }
  free(current_node);
}

int probe_get(Node* head, int index) {
  int i = 0;
  Node* current_node = head;
  while (current_node != NULL && current_node->data != -1) {
    if (i == index) {
      return current_node->data;
    }
    i++;
    current_node = current_node->next;
  }
  printf("PROBE GET FAILED: Bad index or no data in probe\n");
  return -1;
}

//CHECK THIS METHOD!
//Make test cases for probe methods
_Bool probe_remove(Node* head, int data, int i, int hi, Set* set) {
  Node* current_node = head;
  _Bool clipped = false;
  while (current_node != NULL && current_node->data != -1) {
    if (clipped && current_node->next != NULL) {
        current_node->next = (Node*) malloc(sizeof(Node));
        current_node = current_node->next;
        current_node->data = -1;
    }
    if (current_node->data == data) {
        Node* old_head = current_node;
        current_node = old_head->next;
        set->table[i][hi] = current_node;
        free(old_head);
        clipped = true;
    }
    else current_node = current_node->next;
  }
  return false;
}

void print_nodes(Node* head) {
  Node* current_node = head;
  while (current_node != NULL/* && current_node->data != -1*/) {
    printf("%d ", current_node->data);
    if (current_node->next != NULL) current_node = current_node->next;
    else current_node = NULL;
  }
  printf("\n");
}

Set* set_create() {
  Set* result = (Set*) malloc(sizeof(Set));
  result->size = INITIAL_SIZE;
  result->stage = INITIAL_STAGE;
  for (int i=0; i<2; i++) {
    result->locks[i] = malloc(result->size*sizeof(_Bool));
    result->table[i] = malloc(result->size*sizeof(Node**));
    for (int j=0; j<result->size; j++) {
      result->locks[i][j] = false;
      result->table[i][j] = (Node*) malloc(sizeof(Node));
      result->table[i][j]->data = -1;
      Node* current_head = result->table[i][j];
      for (int k=0; k<PROBE_SIZE-1; k++) {
        current_head = node_add(current_head, -1);
      }
      current_head->next = NULL;
    }
  }
  return result;
}

/*
Node* list_build(int size) {
  Node* head = ;
  for (int i = 0; i < size-1; i++) {}
}
*/

int exp_two(int p) {
  int r = 1;
  for (int i = 0; i < p; i++) r = r * 2;
  return r;
}
//Change this to defined hash function to concrete value
/* 
$abstract int h0(int s, int x);
int hash0(Set* set, int x) {
  int r = h0(set->stage, x);
  $assume(0 <= r && r < $pow(2, set->stage));
  return r;
} 

$abstract int h1(int s, int x);
int hash1(Set* set, int x) {
  int r = h1(set->stage, x);
  $assume(0 <= r && r < $pow(2, set->stage));
  return r;
}
*/

int hash0(Set* set, int x) {
  if (hash_vals[0][x] == -1) {
    int s = exp_two(set->stage);
    int choice = $choose_int(s);
    //printf("choice: %s\n", choice);
    hash_vals[0][x] = choice;
    return hash_vals[0][x];
  }
  else return hash_vals[0][x];
}


int hash1(Set* set, int x) {
  if (hash_vals[1][x] == -1) {
    int s = exp_two(set->stage);
    //printf("s val: %s\n", s);
    int choice = $choose_int(s);
    //printf("choice: %s\n", choice);
    hash_vals[1][x] = choice;
    return hash_vals[1][x];
  }
  else return hash_vals[1][x]; 
}


_Bool set_destroy(Set* set) {
  for (int i=0; i<2; i++) {
    for (int j = 0; j<set->size; j++) {
      probe_destroy(set->table[i][j]);
    }
    free(set->table[i]);
    free(set->locks[i]);
  }
  set->size = -1;
  free(set);
  return true;
}

$atomic_f void acquire(Set* set, int x) {
  int h0 = hash0(set, x);
  int h1 = hash1(set, x);
  $when(set->locks[0][h0] == false) set->locks[0][h0] = true;
  $when(set->locks[1][h1] == false) set->locks[1][h1] = true;
}

$atomic_f void release(Set* set, int x) {
  int h0 = hash0(set, x);
  int h1 = hash1(set, x);
  set->locks[0][h0] = false;
  set->locks[1][h1] = false; 
}

void set_print(Set* set) {
  for (int i=0; i<2; i++) {
    printf("Table %d:\n", i);
    for (int j=0; j<set->size; j++) {
        printf("%d: ", j);
        print_nodes(set->table[i][j]);
    }
  }
}

_Bool set_contains(Set* set, int x) {
  acquire(set, x);
  Node* current_node = set->table[0][hash0(set, x)];
  while (current_node->data != -1 && current_node->next != NULL) {
    if (current_node->data == x)
    {
      release(set, x);
      return true;
    }
  }
  current_node = set->table[1][hash1(set, x)];
  while (current_node->data != -1 && current_node->next != NULL) {
    if (current_node->data == x)
    {
      release(set, x);
      return true;
    }
  }
  release(set, x);
  return false;
}

// unsynchronized version of contains, call only from synchronized methods
_Bool present(Set* set, int x) {
  Node* current_node = set->table[0][hash0(set, x)];
  $assert(current_node != NULL);
  while (current_node->data != -1 && current_node->next != NULL) {
    if (current_node->data == x) return true;
    current_node = current_node->next;
  }
  current_node = set->table[1][hash1(set, x)];
  $assert(current_node != NULL);
  while (current_node->data != -1 && current_node->next != NULL) {
    if (current_node->data == x) return true;
    current_node = current_node->next;
  }
  return false;
}

//UNTESTED
_Bool relocate(Set* set, int i, int hi) {
  int hj = 0;
  int j = 1 - i;
  for (int round = 0; round < LIMIT; round++) {
    Node* i_probe = set->table[i][hi];
    int y = probe_get(i_probe, 0);
    switch (i) {
      case 0: hj = hash1(set, y); break;
      case 1: hj = hash0(set, y); break;
    }
    acquire(set, y);
    Node* j_probe = set->table[j][hj];
    if (probe_remove(i_probe, y, i, hi, set)) {
      if (probe_length(j_probe) < THRESHOLD) {
        probe_write(j_probe, y);
        return true;
      }
      else if (probe_length(j_probe) < PROBE_SIZE) {
        probe_write(j_probe, y);
        i = 1 - i;
        hi = hj;
        j = 1 - j;
      }
      else {
        probe_write(i_probe, y);
        return false;
      }
    }
    else if (probe_length(i_probe) >= THRESHOLD) {
      continue;
    }
    else {
      return true;
    }
    release(set, y);
  }
  return false;
}

//UNTESTED
_Bool set_add(Set* set, int x) {
  acquire(set, x);
  int h0 = hash0(set, x);
  int h1 = hash1(set, x);
  int i = -1; //outer index of item to relocate
  int h = -1; //inner index of item to relocate
  _Bool must_resize = false;
  if (x<0 || present(set, x)) return false;
  Node* probe_0 = set->table[0][h0];
  Node* probe_1 = set->table[1][h1];
  if (probe_length(probe_0) < THRESHOLD) {
    probe_write(probe_0, x);
    return true;
  }
  else if (probe_length(probe_1) < THRESHOLD) {
    probe_write(probe_1, x);
    return true;
  }
  else if (probe_length(probe_0) < PROBE_SIZE) {
    probe_write(probe_0, x);
    i = 0;
    h = h0;
  }
  else if (probe_length(probe_1) < PROBE_SIZE) {
    probe_write(probe_1, x);
    i = 1;
    h = h1;
  }
  else must_resize = true;
  release(set, x);
  if (must_resize) {
    //resize(set);
    set_add(set, x);
  }
  else if (!relocate(set, i, h)) {
    //resize(set);
  }
  return true;
}

int test1() {
  Set* s = set_create();

  set_add(s, 1);
  $assert(set_contains(s, 1));
  set_print(s);
  set_destroy(s);
}

int main() {
  test1();
}
