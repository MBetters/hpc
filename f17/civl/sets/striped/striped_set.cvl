/* Concurrent Striped Hash
 * Uses a fixed array of locks to write to hash set
 * Josh Davis 2017 UDel VIP-HPC
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include "../include/set.cvh"

int SIZE = 9;
int LOCKS = SIZE;
int CAP = 3;

struct _set
{
    int** table;          //table array of arrays
    bool* locks;          //locks array
    int items;            //running count of items
    int size;             //number of buckets
    int locksSize;        //number of locks
    int cap;              //limit on bucket entries
};

typedef struct _set Set;

//hash function definition
int set_hash(Set* hash_set, int x)
{
    return (x % hash_set->size);
}

//lock hash function definition
int lock_hash(Set* hash_set, int x)
{
    return (x % hash_set->locksSize);
}

$atomic_f void printLocks(Set* hash_set)
{
    printf("LOCKS STATE:");
    for (int i = 0; i < hash_set->locksSize; i++)
    {
        printf("%s ", hash_set->locks[i]);
    }
    printf("\n");
}

// acquire (true), release (false) locks 
$atomic_f void acquire(Set* hash_set, int value)
{
    $when(hash_set->locks[(value % hash_set->locksSize)] == false) hash_set->locks[lock_hash(hash_set,value)] = true;
    //printf("Lock %s acquired.\n", lock_hash(hash_set,value));
    //printLocks(hash_set);
}

$atomic_f void release(Set* hash_set, int value)
{
    hash_set->locks[lock_hash(hash_set,value)] = false;
    //printf("Lock %s released.\n", lock_hash(hash_set,value));
    //printLocks(hash_set);
}

// contains checks if the value is in the hash set
bool set_contains(Set* hash_set, int value)
{
    acquire(hash_set,value);
    int slot = set_hash(hash_set,value);
    for (int i = 0; i < hash_set->cap; i++)
    {
        if (hash_set->table[slot][i] == value)
        {
            release(hash_set,value);
            return true;
        }
    }
    release(hash_set,value);
    return false;
}

// find item returns the index of the item or -1 if not found
int findItem(Set* hash_set, int value)
{
    acquire(hash_set,value);
    int slot = set_hash(hash_set,value);
    for (int i = 0; i < hash_set->cap; i++)
    {
        if (hash_set->table[slot][i] == value)
        {
            release(hash_set,value);
            return i;
        }
    }
    release(hash_set,value);
    return -1;
}

bool force_add(Set* hash_set, int value)
{
    int slot = set_hash(hash_set,value);
    for (int i = 0; i < hash_set->cap; i++)
    {
        if (hash_set->table[slot][i] == -1)
        {
            hash_set->table[slot][i] = value;
            printf("%s inserted by force_add.\n", value);
            return true;
        }
    }
    printf("Cap failure!");
    return false;
}

//resize policy to check if load factor exceeds a set limit
bool set_policy(Set* hash_set)
{
    double pol = (double) (hash_set->items / (hash_set->size*hash_set->cap));
    return (pol > 0.75);
}

//called if policy is true or a bucket is overfull
bool set_resize(Set* hash_set) 
{
    printf("Time to resize...\n");
    int oldSize = hash_set->size;
    for (int i = 0; i < hash_set->locksSize; i++)
        acquire(hash_set,i);
    if (oldSize == hash_set->size)
    {
        int** old = hash_set->table;
        hash_set->size = hash_set->size * 2;
        hash_set->table = (int **) malloc(hash_set->size * sizeof(int *));
        for (int i = 0; i < hash_set->size; i++)
            hash_set->table[i] = (int *) malloc(hash_set->cap * sizeof(int));

        //init to -1 new table
        for (int i = 0; i < hash_set->size; i++)
            for (int j = 0; j < hash_set->cap; j++)
                hash_set->table[i][j] = -1;

        //rehash values from old table
        for (int i = 0; i < oldSize; i++)   
            for (int j = 0; j < hash_set->cap; j++)
                force_add(hash_set, old[i][j]);

        // free memory
        for (int i = 0; i < oldSize; i++)
            free(old[i]);
        free(old);
    }
    for (int j = 0; j < hash_set->locksSize; j++)
        release(hash_set,j);
}

//adds an item to the set
bool set_add(Set* hash_set, int value)
{
    acquire(hash_set,value);
    bool duplicate = false;
    int slot = set_hash(hash_set,value);
    for (int i = 0; i < hash_set->cap; i++)
    {
        if (hash_set->table[slot][i] == value)
        {
            duplicate = true;
        }
    }
    if(duplicate) //Don't insert duplicates
    {
        printf("%s not inserted, already present.\n", value);
        release(hash_set,value);
        return false;
    }
    else
    {
        int slot = set_hash(hash_set,value);
        for (int i = 0; i < hash_set->cap; i++)
        {
            if (hash_set->table[slot][i] == -1)
            {
                hash_set->table[slot][i] = value;
                //printf("%s inserted.\n", value);
                hash_set->items++;
                release(hash_set,value);
                if (set_policy(hash_set))
                   set_resize(hash_set);
                return true;
            }
        }
        printf("%s not inserted, no capacity.\n", value);
        release(hash_set,value);
        set_resize(hash_set);
        return false;
    }
}

//remove removes items from the set
bool set_remove(Set* hash_set, int value)
{
    bool present = set_contains(hash_set,value);
    int ind = findItem(hash_set,value);
    if(present) //remove
    {
        acquire(hash_set,value);
        hash_set->table[set_hash(hash_set,value)][ind] = -1;
        //printf("%s removed.\n", value);
        hash_set->items--;
        release(hash_set,value);
        return true;
    }
    else
    {
        //printf("%s not removed, not present\n", value);
        return false;
    }
}

void testCheck(Set* hash_set, int value)
{
    if (set_contains(hash_set,value))
        printf("%s found.\n", value);
    else
        printf("%s not found.\n", value);
}

$atomic_f void print_set(Set* hash_set)
{
    printf("TABLE STATE:\n");
    for (int j = 0; j < hash_set->size; j++)
    {
        for (int k = 0; k < hash_set->cap; k++)
            printf("%s ", hash_set->table[j][k]);
        printf("\n");
    }
    printf("# OF ITEMS: %s\n", hash_set->items);
}

Set* set_create()
{
    Set* set;
    set = (Set *) malloc(sizeof(Set));
    set->items = 0; //init item counter
    set->size = 9;
    set->locksSize = set->size;
    set->cap = 5;
        
    //alloc table set->size * set->cap
    set->table = (int **) malloc(set->size * sizeof(int *));
    for (int i = 0; i < set->size; i++)
        set->table[i] = (int *) malloc(set->cap * sizeof(int));

    //init all entries to -1
    for (int i = 0; i < set->size; i++)
        for (int j = 0; j < set->cap; j++)
            set->table[i][j] = -1;
    
    //alloc all locks
    set->locks = (bool *) malloc(set->locksSize * sizeof(bool));

    //init locks at false for all
    for (int k = 0; k < set->locksSize; k++)
        set->locks[k] = false;

    return set;
}

bool set_destroy(Set* sHash){
     //free memory
    for (int l = 0; l < sHash->size; l++)
        free(sHash->table[l]);
    free(sHash->table);
    free(sHash->locks);
    free(sHash);
    return true;
}

/*
int main(int argc, char* argv[])
{
    Set* sHash;
    sHash = set_create();
    
    $parfor (int i : 0 .. 5)
    {
        $for (int j : 1 .. 2)
        {
            set_add(sHash,10);
        }
    }
    
    print_set(sHash);
    return 0;
}*/
