#include <stdio.h>
#include <stdlib.h>
#include "linked_list.h"

#define LOAD_FACTOR 0.75

int SIZE = 5;
_Bool LOCK = false;
struct _set;

typedef struct _set{
	List** table; // array of linked lists
	_Bool lock; // lock to enable concurrent operations
	int items; // number of items in the set
} Set;

_Bool set_policy(Set* set){
    float numerator = set->items;
    float denominator = SIZE;
    float result = (float)(numerator / denominator);
    printf("policy val = %0.2f\n", result);
    return (result > 0.75); 
}

int hash_fxn(int x){
    return (x % SIZE);
}

// acquire (-1), release (0) locks
$atomic_f void acquire(Set* hash_set, int value)
{
    $when(hash_set->lock == false) hash_set->lock = true;
}

$atomic_f void release(Set* hash_set, int value)
{
    hash_set->lock = false;
}

// resize and rehash 
_Bool set_resize(Set* hash_set){
	int old_size = SIZE;
    int new_size = old_size*2;
	List** new_table;
    // allocate memory for new table
	new_table = (List **) malloc (new_size * sizeof(List*));
	for (int i = 0; i < new_size; i++){
        new_table[i] =  create_list(-1);
	}
    // rehash from old table to new table
    List** old_table = hash_set->table;
    SIZE = new_size; // update hash_fxn
    for(int i = 0; i < old_size; i++){
        List* temp = old_table[i];
        while(temp != NULL){ // hash all values in list
            int value = temp->val;
            if(value != -1){ // -1 = null val, ignore 
                int hash_val = hash_fxn(value);
                append_list(new_table[hash_val], value); 
            }
            temp = temp->next;
        }
    }
    for(int i = 0; i < old_size; i++){
		free_list(old_table[i]);
	}
	free(old_table);
    hash_set->table = new_table;
    return true;
}

// check if list at hash contains the value within lock
_Bool set_contains(Set* hash_set, int value){
	acquire(hash_set,value);
	int hash_val;
    hash_val = hash_fxn(value); // hash value
    _Bool result = contains_list(hash_set->table[hash_val], value);  
	release(hash_set,value);
	return result;
}

// add an element to the hash set
_Bool set_add(Set* hash_set, int value){
	acquire(hash_set,value);

	int hash_val;
	hash_val = hash_fxn(value); 
    _Bool contains = contains_list(hash_set->table[hash_val], value);
	if (!contains){ // if the hash set does not contain the element
        append_list(hash_set->table[hash_val], value);
		printf("added %d to table[%d]\n", value, hash_fxn(value));
		hash_set->items+=1;
		if(set_policy(hash_set)){
			set_resize(hash_set);
		}
		release(hash_set,value);
		return true;
	}
	else{
		release(hash_set,value);
		return false;
	}
}

// remove a value from the hash set
_Bool set_remove(Set* hash_set, int value){
	acquire(hash_set,value);
	
	int hash_val;
    hash_val = hash_fxn(value);
    _Bool contains = contains_list(hash_set->table[hash_val], value);
	if (contains){
        remove_list(&(hash_set->table[hash_val]), value);
        //append_list(hash_set->table[hash_val], -1); // null val
		hash_set->items-=1;
		release(hash_set,value);
		return true;
    } else {
		release(hash_set,value);
		return false;
	}
}

void print_hash(Set* hash_set){
   // print table
   printf("table: ");
   for(int i = 0; i < SIZE; i++){
       printf("table[%d]: ", i);
       print_list(hash_set->table[i]);
   }
   printf("\n");
}

Set* set_create(){
	Set *set;
	set = (Set *) malloc (sizeof(Set));
	set->items = 0;
	set->lock = false;
	set->table = (List**) malloc(SIZE * sizeof(List*)); //table of size 5
	for (int i = 0; i < SIZE; i++){
		set->table[i] = create_list(-1); // default empty value (-1)
	}
	return set;
}

_Bool set_destroy(Set* set){
	for(int i = 0; i < SIZE; i++){
		free_list(set->table[i]);
	}
	free(set->table);
	free(set);
	return true;
}

int main(){
	Set* set = set_create();

	set_add(set,20);
	print_hash(set);
	set_add(set,17);
	print_hash(set);
	set_remove(set,17);
	print_hash(set);
    set_remove(set,19);
    print_hash(set);
	set_add(set,46);
	print_hash(set);
	set_add(set,30);
	print_hash(set);
    set_add(set,2);
    print_hash(set);

	set_destroy(set);
	return 0;
}
