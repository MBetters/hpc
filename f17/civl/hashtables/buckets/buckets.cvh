#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include "../set.cvh"
#include "atomic.cvh"

#define WORD_SIZE 24
#define LO_MASK  0x1
#define HI_MASK 0x008000000
#define MASK  0x00FFFFFF

/* must define:
 * - window
 * - bucketlist 
 */

/* --------------- forward declarations ----------- */

int SIZE;
int LENGTH;

typedef struct _window{
    Node* pred;
    Node* curr;
} Window;

Window* find(Node* head, int key);

typedef struct _bucketlist{
    Node* head;
    Node* next;
    int size;
} Bucketlist;

int hash(int key);
int hashCode(int key);
int reverse(int key);
int makeRegularKey(int key);
int makeSentinelKey(int key);

/* ----------------------- end -------------------- */


typedef struct _window{
    Node* pred;
    Node* curr;
} Window;

typedef struct _bucketlist{
    Node* head;
    Node* next;
    int size;
} Bucketlist;

Window* find(Node* head, int key){
    Node* pred = head;
    Node* curr = head->next;
    Window* new_window;
    while(curr->val < key){
        pred = curr;
        curr = pred->next;
    }
    new_window->pred = pred;
    new_window->curr = curr;
    return new_window;
};

// hash by size
int hash(int key){
    return key % size;
};

// placeholder replacement for Java's hashCode()
int hashCode(int key){
    return hash(key) & MASK; // restricted by mask 
}

// returns reverse based on key, masks
int reverse(int key){
    int loMask = LO_MASK;
    int hiMask = HI_MASK;
    int result = 0;
    for(int i = 0; i < WORD_SIZE; i++){
        if((key & loMask) != 0){ // bit set
            result |= hiMask;
        }
        loMask = loMask << 1;
        hiMask = hiMask >> 1; // fill with 0 from left
    }
    return result;
}

int makeRegularKey(int val){
    int code = hashCode(val); // mask hashed val
    return reverse(code | HI_MASK); 
}

/* A bucket consists of a reference into our list
 * When resizing, move buckets rather than individual items
 * Implemented using: 
 * - The combination of a modulo-size hash and a 2^i table size.
 * - Recursive split-ordering
 *
 * Given i, where 2^i = SIZE, and b, a logical table bucket
 * An item k maintains 'k mod 2^i = b' 
 * When resizing, such that SIZE = 2^(i+1),
 * the items in the bucket are split between bucket b... 
 * ...and a new bucket, such that'k mod 2^(i+1) = b + 2^i'.
 * Resize is incremental
 *
 * Recursive split-ordering is achieved through binary reversal
 * - reversing most-significant bits with least-significant bits
 * 00011 -> 11000
 *
 * Used in (concurrent) LockFreeHashSet, holds an array of bucketlists
 */

/* Atomic Markable Reference
 * compareAndSet(expected-val,new-val,expected-mark,new-mark) 
 * updates if curr=expected
 * in Shavit's implementation, checks Node vals
 * add: if Nodes not equal, stop and don't add
 * otherwise continue
 */

/* To insert a key into our hash table
 * The key must be hashed using recursive split-ordering
 * ...following the pointer to the appropriate location in the sorted items list
 * ...and traversing the list until the key's proper location is found 
 */ 


