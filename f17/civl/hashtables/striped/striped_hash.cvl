/* Concurrent Striped Hash
 * Uses a fixed array of locks to write to hash set
 * Josh Davis 2017 UDel VIP-HPC
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include "../set.cvh"

int SIZE = 9;
int LOCKS = SIZE;
int CAP = 3;

struct _set;

typedef struct _set
{
    int** table; // table
    bool* locks; // locks
    int items; //running count of items
} Set;

//hash function definition
int hash(int x)
{
    return (x % SIZE);
}

//lock hash function definition
int lock_hash(int x)
{
    return (x % LOCKS);
}

// acquire (-1), release (0) locks (implement _Bool)
void acquire(Set* hash_set, int value)
{
    $when(hash_set->locks[((value % SIZE) & LOCKS)] == false) hash_set->locks[lock_hash(value)] = true;
    printf("Lock %s acquired.\n", lock_hash(value));
}

void release(Set* hash_set, int value)
{
    hash_set->locks[lock_hash(value)] = false;
    printf("Lock %s released.\n", lock_hash(value));
}

// contains checks if the value is in the hash set
bool contains(Set* hash_set, int value)
{
    acquire(hash_set,value);
    int slot = hash(value);
    for (int i = 0; i < CAP; i++)
    {
        if (hash_set->table[slot][i] == value)
        {
            release(hash_set,value);
            //return (i+1);
            return true;
        }
    }
    release(hash_set,value);
    return false;
}

// find item returns the index of the item or -1 if not found
int findItem(Set* hash_set, int value)
{
    acquire(hash_set,value);
    int slot = hash(value);
    for (int i = 0; i < CAP; i++)
    {
        if (hash_set->table[slot][i] == value)
        {
            release(hash_set,value);
            return i;
        }
    }
    release(hash_set,value);
    return -1;
}

//resize policy to check if load factor exceeds a set limit
int policy(Set* hash_set) //UNIMPLEMENTED
{
    double pol = (double) (hash_set->items / (SIZE*CAP));
    return (pol > 0.75);
}

//called if policy is true or a bucket is overfull
bool resize(Set* hash_set) //UNIMPLEMENTED
{
    printf("Time to resize...\n");
    int oldSIZE = SIZE;
    for (int i = 0; i < LOCKS; i++)
        acquire(hash_set,i);
    if (oldSIZE == SIZE)
    {
        int** temp[SIZE][CAP]; //Making a copy of the current table
        printf("Generating memcpy...\n");
        memcpy(temp, hash_set->table, sizeof(hash_set->table));
        printf("TEMP TABLE STATE:\n");
        for (int j = 0; j < SIZE; j++)
        {
            for (int k = 0; k < CAP; k++)
                printf("%d ", temp[j][k]);
            printf("\n");
        }
    }
    for (int j = 0; j < LOCKS; j++)
        release(hash_set,j);
}

/*
 * Notes on resize steps:
 * 1. Acquire all locks *
 * 2. Make sure the table hasn't been resized already *
 * 3. Make a temp copy of the table *
 * 4. Resize (x2) the "real" table in memory, changing hash()
 * 5. Reinit the real table to all 0's
 * 6. Place every item in temp in real using new hash()
 * 7. Free temp, release all locks
*/

//adds an item to the set
bool add(Set* hash_set, int value)
{
    if(contains(hash_set,value)) //Don't insert duplicates
    {
        printf("%s not inserted, already present.\n", value);
        return false;
    }
    else
    {
        acquire(hash_set,value);
        int slot = hash(value);
        for (int i = 0; i < CAP; i++)
        {
            if (hash_set->table[slot][i] == 0)
            {
                hash_set->table[slot][i] = value;
                printf("%s inserted.\n", value);
                hash_set->items++;
                release(hash_set,value);
                //if (policy(hash_set))
                //   resize(hash_set);
                return true;
            }
        }
        printf("%s not inserted, no capacity.\n", value);
        release(hash_set,value);
        //resize(hash_set);
        return false;
    }
}

//discard removes items from the set
bool discard(Set* hash_set, int value)
{
    bool present = contains(hash_set,value);
    int ind = findItem(hash_set,value);
    if(present) //remove
    {
        acquire(hash_set,value);
        hash_set->table[hash(value)][ind] = 0;
        printf("%s removed.\n", value);
        hash_set->items--;
        release(hash_set,value);
        return true;
    }
    else
    {
        printf("%s not removed, not present\n", value);
        return false;
    }
}


void testCheck(Set* hash_set, int value)
{
    if (contains(hash_set,value))
        printf("%s found.\n", value);
    else
        printf("%s not found.\n", value);
}

void printTable(Set* hash_set)
{
    printf("TABLE STATE:\n");
    for (int j = 0; j < SIZE; j++)
    {
        for (int k = 0; k < CAP; k++)
            printf("%s ", hash_set->table[j][k]);
        printf("\n");
    }
    printf("# OF ITEMS: %s\n", hash_set->items);
}

void printLocks(Set* hash_set)
{
    printf("LOCKS STATE:");
    for (int i = 0; i < LOCKS; i++)
    {
        printf("%s ", hash_set->locks[i]);
    }
    printf("\n");
}

int main(int argc, char* argv[])
{
    Set sHash;
    sHash.items = 0; //init item counter
        
    //alloc table SIZE * CAP
    sHash.table = (int **) malloc(SIZE * sizeof(int *));
    for (int i = 0; i < SIZE; i++)
       sHash.table[i] = (int *) malloc(CAP * sizeof(int));
    
    //init table at 0 for all elements
    for (int j = 0; j < SIZE; j++)
        for (int k = 0; k < CAP; k++)
            sHash.table[j][k] = 0;

    //alloc all locks at open (0)
    sHash.locks = (bool *) malloc(LOCKS * sizeof(bool));

    //init locks at false for all
    for (int k = 0; k < LOCKS; k++)
        sHash.locks[k] = false;

    
    //basic tests
    printTable(&sHash);
    add(&sHash,15);
    add(&sHash,11);
    add(&sHash,29);
    add(&sHash,30);
    add(&sHash,42);
    printTable(&sHash);
    discard(&sHash,15);
    testCheck(&sHash,15);
    testCheck(&sHash,24);
    discard(&sHash,18);
    printTable(&sHash);
    

    /*
    $parfor (int i : 0 .. 4)
    {
        add(&sHash,i+1);
        add(&sHash,i*2);
        add(&sHash,i*4);
    }
    */
    printTable(&sHash);
    
    //free memory
    for (int l = 0; l < SIZE; l++)
        free(sHash.table[l]);
    free(sHash.table);
    free(sHash.locks);
    return 0;
}
