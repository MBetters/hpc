#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include "../set.cvh"


// Concurrent Striped Hash
// Uses a fixed number of locks to write to hash table

int SIZE = 9;
int LOCKS = SIZE;
int CAP = 3;


struct StripedHash
{
    int** table; // table
    bool* locks; // locks
    int items;
};


//hash function definition
int hash(int x)
{
    return (x % SIZE);
}

//lock hash function definition
int lock_hash(int x)
{
    return ((x % SIZE) & LOCKS);
}

// acquire (-1), release (0) locks (implement _Bool)
void acquire(int x, struct StripedHash *s)
{
    $when(s->locks[((x % SIZE) & LOCKS)] == false) s->locks[lock_hash(x)] == true;
    printf("Lock %s acquired.\n", lock_hash(x));
}

void release(int x, struct StripedHash *s)
{
    s->locks[hash(x)] == false;
    printf("Lock %s released.\n", hash(x));
}

// add, remove, contains
int contains(int x, struct StripedHash *s)
{
    acquire(x,s);
    int slot = hash(x);
    for (int i = 0; i < CAP; i++)
    {
        if (s->table[slot][i] == x)
        {
            release(x,s);
            return (i+1);
        }
    }
    release(x,s);
    return 0;
}


//resize policy
int policy(struct StripedHash *s) //UNIMPLEMENTED
{
    double pol = (double) (s->items / (SIZE*CAP));
    return (pol > 0.75);
}

void resize(struct StripedHash *s) //UNIMPLEMENTED
{
    printf("Time to resize...\n");
    int oldSIZE = SIZE;
    for (int i = 0; i < LOCKS; i++)
        acquire(i,s);
    if (oldSIZE == SIZE)
    {
        int** temp[SIZE][CAP]; //Making a copy of the current table
        printf("Generating memcpy...\n");
        memcpy(temp, s->table, sizeof(s->table));
        printf("TEMP TABLE STATE:\n");
        for (int j = 0; j < SIZE; j++)
        {
            for (int k = 0; k < CAP; k++)
                printf("%d ", temp[j][k]);
            printf("\n");
        }
    }
    for (int j = 0; j < LOCKS; j++)
        release(j,s);
}

/*
Notes on resize steps:
1. Acquire all locks *
2. Make sure the table hasn't been resized already *
3. Make a temp copy of the table *
4. Resize (x2) the "real" table in memory, changing hash()
5. Reinit the real table to all 0's
6. Place every item in temp in real using new hash()
7. Free temp, release all locks
*/

int add(int x, struct StripedHash *s)
{
    if(contains(x,s)) //Don't insert duplicates
    {
        printf("%s not inserted, already present.\n", x);
        return 0;
    }
    else
    {
        acquire(x,s);
        int slot = hash(x);
        for (int i = 0; i < CAP; i++)
        {
            if (s->table[slot][i] == 0)
            {
                s->table[slot][i] = x;
                printf("%s inserted.\n", x);
                s->items++;
                release(x,s);
                if (policy(s))
                   resize(s);
                return 1;
            }
        }
        printf("%s not inserted, no capacity.\n", x);
        release(x,s);
        resize(s);
        return 0;
    }
}

int hashRemove(int x, struct StripedHash *s)
{
    int ind = contains(x,s);
    if(ind > 0) //remove
    {
        acquire(x,s);
        s->table[hash(x)][(ind-1)] = 0;
        printf("%s removed.\n", x);
        s->items--;
        release(x,s);
        return 1;
    }
    else
    {
        printf("%s not removed, not present\n", x);
        return 0;
    }
}

void testCheck(int x, struct StripedHash *s)
{
    if (contains(x,s))
        printf("%s found.\n", x);
    else
        printf("%s not found.\n", x);
}

void printTable(struct StripedHash *s)
{
    printf("TABLE STATE:\n");
    for (int j = 0; j < SIZE; j++)
    {
        for (int k = 0; k < CAP; k++)
            printf("%s ", s->table[j][k]);
        printf("\n");
    }
    printf("# OF ITEMS: %s\n", s->items);
}

int main(int argc, char* argv[])
{
    struct StripedHash sHash;
    sHash.items = 0; //init item counter
        
    //alloc table SIZE * CAP
    sHash.table = (int **) malloc(SIZE * sizeof(int *));
    for (int i = 0; i < SIZE; i++)
       sHash.table[i] = (int *) malloc(CAP * sizeof(int));
    
    //init table at 0 for all elements
    for (int j = 0; j < SIZE; j++)
        for (int k = 0; k < CAP; k++)
            sHash.table[j][k] = 0;

    //alloc all locks at open (0)
    sHash.locks = (bool *) malloc(LOCKS * sizeof(bool));

    //init locks at false for all
    for (int k = 0; k < LOCKS; k++)
        sHash.locks[k] = false;

    /*
    //basic tests
    printTable(&sHash);
    add(15,&sHash);
    add(15,&sHash);
    add(24,&sHash);
    add(33,&sHash);
    add(42,&sHash);
    printTable(&sHash);
    hashRemove(15,&sHash);
    testCheck(15,&sHash);
    testCheck(24,&sHash);
    hashRemove(18,&sHash);
    printTable(&sHash);
    */

    $parfor (int i : 0 .. 5)
    {
        add(i+1,&sHash);
        add(i*2,&sHash);
        add(i*4,&sHash);
    }

    printTable(&sHash);

    //free memory
    for (int l = 0; l < SIZE; l++)
        free(sHash.table[l]);
    free(sHash.table);
    free(sHash.locks);
    return 0;
}