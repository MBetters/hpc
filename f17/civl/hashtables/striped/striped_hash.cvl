/* Concurrent Striped Hash
 * Uses a fixed array of locks to write to hash set
 * Josh Davis 2017 UDel VIP-HPC
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include "../set.cvh"

int SIZE = 9;
int LOCKS = SIZE;
int CAP = 3;

struct _set;

typedef struct _set
{
    int** table;          //table array of arrays
    bool* locks;          //locks array
    int items;            //running count of items
    int size;             //number of buckets
    int locksSize;        //number of locks
    int cap;              //limit on bucket entries
} Set;

//hash function definition
int set_hash(Set* hash_set, int x)
{
    return (x % hash_set->size);
}

//lock hash function definition
int lock_hash(Set* hash_set, int x)
{
    return (x % hash_set->locksSize);
}

// acquire (-1), release (0) locks (implement _Bool)
void acquire(Set* hash_set, int value)
{
    $when(hash_set->locks[(value % hash_set->locksSize)] == false) hash_set->locks[lock_hash(hash_set,value)] = true;
    printf("Lock %s acquired.\n", lock_hash(hash_set,value));
}

void release(Set* hash_set, int value)
{
    hash_set->locks[lock_hash(hash_set,value)] = false;
    printf("Lock %s released.\n", lock_hash(hash_set,value));
}

// contains checks if the value is in the hash set
bool set_contains(Set* hash_set, int value)
{
    acquire(hash_set,value);
    int slot = set_hash(hash_set,value);
    for (int i = 0; i < hash_set->cap; i++)
    {
        if (hash_set->table[slot][i] == value)
        {
            release(hash_set,value);
            return true;
        }
    }
    release(hash_set,value);
    return false;
}

// find item returns the index of the item or -1 if not found
int findItem(Set* hash_set, int value)
{
    acquire(hash_set,value);
    int slot = set_hash(hash_set,value);
    for (int i = 0; i < hash_set->cap; i++)
    {
        if (hash_set->table[slot][i] == value)
        {
            release(hash_set,value);
            return i;
        }
    }
    release(hash_set,value);
    return -1;
}

bool force_add(Set* hash_set, int value)
{
    int slot = set_hash(hash_set,value);
    for (int i = 0; i < hash_set->cap; i++)
    {
        if (hash_set->table[slot][i] == 0)
        {
            hash_set->table[slot][i] = value;
            printf("%s inserted by force_add.\n", value);
            return true;
        }
    }
    printf("Cap failure!");
    return false;
}

//resize policy to check if load factor exceeds a set limit
int set_policy(Set* hash_set) //UNIMPLEMENTED
{
    double pol = (double) (hash_set->items / (hash_set->size*hash_set->cap));
    return (pol > 0.75);
}

//called if policy is true or a bucket is overfull
bool set_resize(Set* hash_set) //UNIMPLEMENTED
{
    printf("Time to resize...\n");
    int oldSize = hash_set->size;
    for (int i = 0; i < hash_set->locksSize; i++)
        acquire(hash_set,i);
    if (oldSize == hash_set->size)
    {
        printf("Initializing temp copy...\n");
        int** temp; //Making a copy of the current table
        temp = (int **) malloc(oldSize * sizeof(int *));
        for (int i = 0; i < oldSize; i++)
            temp[i] = (int *) calloc(hash_set->cap, sizeof(int));
        printf("Copying values...\n");
        for (int j = 0; j < oldSize; j++)
        {
            for (int k = 0; k < hash_set->cap; k++)
                temp[j][k] = hash_set->table[j][k];
        }
        printf("TEMP TABLE STATE:\n");
        for (int j = 0; j < oldSize; j++)
        {
            for (int k = 0; k < hash_set->cap; k++)
                printf("%d ", temp[j][k]);
            printf("\n");
        }
        int** old = hash_set->table;
        hash_set->size = hash_set->size * 2;
        hash_set->table = (int **) malloc(hash_set->size * sizeof(int *));
        for (int i = 0; i < hash_set->size; i++)
            hash_set->table[i] = (int *) calloc(hash_set->cap, sizeof(int));
        for (int i = 0; i < oldSize; i++)
            for (int j = 0; j < hash_set->cap; j++)
                force_add(hash_set, old[i][j]);

        // free memory
        for (int l = 0; l < oldSize; l++)
            free(temp[l]);
        free(temp);
        for (int i = 0; i < oldSize; i++)
            free(old[i]);
        free(old);

    }
    for (int j = 0; j < hash_set->locksSize; j++)
        release(hash_set,j);
}

/*
 * Notes on resize steps:
 * 1. Acquire all locks *
 * 2. Make sure the table hasn't been resized already *
 * 3. Make a temp copy of the table *
 * 4. Resize (x2) the "real" table in memory, changing hash()
 * 5. Reinit the real table to all 0's
 * 6. Place every item in temp in real using new hash()
 * 7. Free temp, release all locks
*/

//adds an item to the set
bool set_add(Set* hash_set, int value)
{
    if(set_contains(hash_set,value)) //Don't insert duplicates
    {
        printf("%s not inserted, already present.\n", value);
        return false;
    }
    else
    {
        acquire(hash_set,value);
        int slot = set_hash(hash_set,value);
        for (int i = 0; i < hash_set->cap; i++)
        {
            if (hash_set->table[slot][i] == 0)
            {
                hash_set->table[slot][i] = value;
                printf("%s inserted.\n", value);
                hash_set->items++;
                release(hash_set,value);
                if (set_policy(hash_set))
                   set_resize(hash_set);
                return true;
            }
        }
        printf("%s not inserted, no capacity.\n", value);
        release(hash_set,value);
        set_resize(hash_set);
        return false;
    }
}

//remove removes items from the set
bool set_remove(Set* hash_set, int value)
{
    bool present = set_contains(hash_set,value);
    int ind = findItem(hash_set,value);
    if(present) //remove
    {
        acquire(hash_set,value);
        hash_set->table[set_hash(hash_set,value)][ind] = 0;
        printf("%s removed.\n", value);
        hash_set->items--;
        release(hash_set,value);
        return true;
    }
    else
    {
        printf("%s not removed, not present\n", value);
        return false;
    }
}


void testCheck(Set* hash_set, int value)
{
    if (set_contains(hash_set,value))
        printf("%s found.\n", value);
    else
        printf("%s not found.\n", value);
}

void printTable(Set* hash_set)
{
    printf("TABLE STATE:\n");
    for (int j = 0; j < hash_set->size; j++)
    {
        for (int k = 0; k < hash_set->cap; k++)
            printf("%s ", hash_set->table[j][k]);
        printf("\n");
    }
    printf("# OF ITEMS: %s\n", hash_set->items);
}

void printLocks(Set* hash_set)
{
    printf("LOCKS STATE:");
    for (int i = 0; i < hash_set->locksSize; i++)
    {
        printf("%s ", hash_set->locks[i]);
    }
    printf("\n");
}

int main(int argc, char* argv[])
{
    Set sHash;
    sHash.items = 0; //init item counter
    sHash.size = 9;
    sHash.locksSize = sHash.size;
    sHash.cap = 3;
        
    //alloc table sHash.size * sHash.cap
    sHash.table = (int **) malloc(sHash.size * sizeof(int *));
    for (int i = 0; i < sHash.size; i++)
       sHash.table[i] = (int *) calloc(sHash.cap, sizeof(int));
    
    /*
    //init table at 0 for all elements
    for (int j = 0; j < sHash.size; j++)
        for (int k = 0; k < sHash.cap; k++)
            sHash.table[j][k] = 0;
    */

    //alloc all locks at open (0)
    sHash.locks = (bool *) malloc(sHash.locksSize * sizeof(bool));

    //init locks at false for all
    for (int k = 0; k < sHash.locksSize; k++)
        sHash.locks[k] = false;

    printTable(&sHash);
    set_add(&sHash,9);
    set_add(&sHash,11);
    set_add(&sHash,18);
    set_add(&sHash,36);
    printTable(&sHash);
    printLocks(&sHash);
    set_add(&sHash,45);
    printTable(&sHash);

    /*
    //basic tests
    printTable(&sHash);
    set_add(&sHash,15);
    set_add(&sHash,11);
    set_add(&sHash,29);
    set_add(&sHash,30);
    set_add(&sHash,42);
    printTable(&sHash);
    set_remove(&sHash,15);
    testCheck(&sHash,15);
    testCheck(&sHash,24);
    set_remove(&sHash,18);
    printTable(&sHash);
    */

    /*
    $parfor (int i : 0 .. 4)
    {
        set_add(&sHash,i+1);
        set_add(&sHash,i*2);
        set_add(&sHash,i*4);
    }
    */
    printTable(&sHash);
    
    //free memory
    for (int l = 0; l < sHash.size; l++)
        free(sHash.table[l]);
    free(sHash.table);
    free(sHash.locks);
    return 0;
}
